@using _4kampf.Web.Services
@using _4kampf.Shared.Models
@using System.Net.Http
@inject ProjectFileService ProjectFile
@inject CodeEditorService CodeEditor
@inject IJSRuntime JSRuntime
@inject IHttpClientFactory HttpClientFactory
@rendermode InteractiveServer

<div class="sointu-song-manager @(IsVisible ? "visible" : "")">
    <div class="song-manager-header">
        <h5>Sointu Song Manager</h5>
        <button class="btn-close" @onclick="Close" type="button">Ã—</button>
    </div>
    
    <div class="song-manager-content">
        @if (CurrentProject == null)
        {
            <div class="alert alert-warning">
                No project selected. Please create or load a project first.
            </div>
        }
        else
        {
            <div class="song-manager-section">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h6>Song Files</h6>
                    <div>
                        <button class="btn btn-sm btn-primary" @onclick="CreateNewSong" type="button">
                            <span>+</span> New Song
                        </button>
                        <button class="btn btn-sm btn-secondary" @onclick="LoadExampleSong" type="button">
                            Load Example
                        </button>
                    </div>
                </div>
                
                @if (isLoading)
                {
                    <div class="text-center py-3">
                        <span class="spinner-border spinner-border-sm" role="status"></span>
                        <span class="ms-2">Loading...</span>
                    </div>
                }
                else if (!songFiles.Any())
                {
                    <div class="alert alert-info">
                        No song files found. Create a new song or load an example.
                    </div>
                }
                else
                {
                    <div class="list-group">
                        @foreach (var songFile in songFiles)
                        {
                            <div class="list-group-item d-flex justify-content-between align-items-center @(songFile == selectedSong ? "active" : "")">
                                <div class="d-flex align-items-center">
                                    <input type="radio" 
                                           name="selectedSong" 
                                           checked="@(songFile == selectedSong)"
                                           @onchange="@(() => SelectSong(songFile))"
                                           class="form-check-input me-2" />
                                    <span>@songFile</span>
                                    @if (songFile == CurrentProject.SointuSongFile || (songFile == "song.yml" && string.IsNullOrEmpty(CurrentProject.SointuSongFile)))
                                    {
                                        <span class="badge bg-primary ms-2">Active</span>
                                    }
                                </div>
                                <div>
                                    <button class="btn btn-sm btn-outline-primary" @onclick="@(() => EditSong(songFile))" type="button">
                                        Edit
                                    </button>
                                    <button class="btn btn-sm btn-outline-danger" @onclick="@(() => DeleteSong(songFile))" type="button">
                                        Delete
                                    </button>
                                </div>
                            </div>
                        }
                    </div>
                }
            </div>
            
            @if (editingSong != null)
            {
                <div class="song-manager-section mt-4">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6>Editing: @editingSong</h6>
                        <div>
                            <button class="btn btn-sm btn-success" @onclick="SaveSong" type="button">Save</button>
                            <button class="btn btn-sm btn-secondary" @onclick="CancelEdit" type="button">Cancel</button>
                        </div>
                    </div>
                    <div id="song-editor" class="monaco-editor-container" style="height: 400px;"></div>
                </div>
            }
        }
    </div>
</div>

@code {
    [Parameter] public Project? CurrentProject { get; set; }
    [Parameter] public EventCallback<Project> ProjectChanged { get; set; }
    [Parameter] public EventCallback<string> OnLog { get; set; }
    
    private bool isVisible = false;
    private bool isLoading = false;
    private List<string> songFiles = new();
    private string? selectedSong;
    private string? editingSong;
    private string? editingContent;
    private bool editorInitialized = false;
    private DotNetObjectReference<CodeEditorCallback>? editorCallbackRef;
    private string? pendingEditSong;
    private bool _isInitializing = false;
    
    protected override async Task OnParametersSetAsync()
    {
        // Refresh song list when project changes
        if (IsVisible && CurrentProject != null)
        {
            await LoadSongFilesAsync();
        }
        await base.OnParametersSetAsync();
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // After DOM updates, initialize editor if we have a pending edit
        // Use a flag to prevent multiple simultaneous initializations
        if (pendingEditSong != null && editingSong != null && IsVisible && !_isInitializing)
        {
            _isInitializing = true;
            
            try
            {
                // Wait for sidebar animation (300ms) plus buffer, then poll for container
                await Task.Delay(400);
                
                // Poll for container to appear (with timeout)
                bool containerReady = false;
                for (int i = 0; i < 10; i++)
                {
                    try
                    {
                        containerReady = await JSRuntime.InvokeAsync<bool>("eval", 
                            "document.getElementById('song-editor') !== null");
                        if (containerReady) break;
                        await Task.Delay(100);
                    }
                    catch
                    {
                        // Ignore errors during polling
                    }
                }
                
                if (containerReady)
                {
                    await InitializeEditorAsync();
                }
                else
                {
                    await LogAsync("Error: song-editor container never appeared in DOM");
                }
            }
            finally
            {
                pendingEditSong = null;
                _isInitializing = false;
                // Force another render to ensure UI updates
                StateHasChanged();
            }
        }
        await base.OnAfterRenderAsync(firstRender);
    }
    
    public bool IsVisible
    {
        get => isVisible;
        set
        {
            if (isVisible != value)
            {
                isVisible = value;
                if (isVisible && CurrentProject != null)
                {
                    _ = LoadSongFilesAsync();
                }
            }
        }
    }
    
    public void Show()
    {
        IsVisible = true;
        // Force refresh when shown to ensure we detect the current song
        if (CurrentProject != null)
        {
            _ = LoadSongFilesAsync();
        }
    }
    
    public void Close()
    {
        IsVisible = false;
        editingSong = null;
        editingContent = null;
        pendingEditSong = null;
        if (editorInitialized)
        {
            _ = CodeEditor.DestroyEditorAsync("song-editor");
            editorInitialized = false;
            editorCallbackRef?.Dispose();
            editorCallbackRef = null;
        }
    }
    
    private async Task LoadSongFilesAsync()
    {
        if (CurrentProject == null) return;
        
        isLoading = true;
        try
        {
            songFiles = (await ProjectFile.ListSointuSongsAsync(CurrentProject.Name)).ToList();
            
            // Prioritize the project's current song file, or first available, or default
            if (!string.IsNullOrEmpty(CurrentProject.SointuSongFile))
            {
                // Check if the current song file exists in the list
                if (songFiles.Contains(CurrentProject.SointuSongFile))
                {
                    selectedSong = CurrentProject.SointuSongFile;
                }
                else if (songFiles.Any())
                {
                    // Current song file not found, use first available
                    selectedSong = songFiles.First();
                }
                else
                {
                    // No songs found, use the project's song file name (it might exist but not be listed)
                    selectedSong = CurrentProject.SointuSongFile;
                }
            }
            else if (songFiles.Any())
            {
                selectedSong = songFiles.First();
            }
            else
            {
                selectedSong = "song.yml";
            }
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await LogAsync($"Error loading song files: {ex.Message}");
        }
        finally
        {
            isLoading = false;
        }
    }
    
    private void SelectSong(string songFile)
    {
        selectedSong = songFile;
        if (CurrentProject != null)
        {
            CurrentProject.SointuSongFile = songFile;
            _ = ProjectChanged.InvokeAsync(CurrentProject);
            _ = LogAsync($"Selected song: {songFile}");
        }
    }
    
    private async Task CreateNewSong()
    {
        if (CurrentProject == null) return;
        
        string newFileName = $"song_{DateTime.Now:yyyyMMdd_HHmmss}.yml";
        string template = @"bpm: 120
rowsperbeat: 4
score:
    rowsperpattern: 16
    length: 1
    tracks:
        - numvoices: 1
          order: [0]
          patterns:
              - [60, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
patch:
    - numvoices: 1
      units:
          - type: envelope
            parameters:
                attack: 16
                decay: 32
                gain: 128
                release: 64
                stereo: 0
                sustain: 96
          - type: oscillator
            parameters:
                color: 64
                detune: 64
                gain: 128
                lfo: 0
                phase: 0
                shape: 64
                stereo: 0
                transpose: 64
                type: 0
                unison: 0
          - type: out
            parameters:
                gain: 64
                stereo: 1
";
        
        bool saved = await ProjectFile.SaveSointuSongAsync(CurrentProject.Name, template, newFileName);
        if (saved)
        {
            await LogAsync($"Created new song: {newFileName}");
            await LoadSongFilesAsync();
            await EditSong(newFileName);
        }
        else
        {
            await LogAsync($"Error creating song: {newFileName}");
        }
    }
    
    private async Task LoadExampleSong()
    {
        if (CurrentProject == null) return;
        
        try
        {
            // Try to load example via HTTP
            string exampleContent = "";
            try
            {
                using var http = HttpClientFactory.CreateClient();
                exampleContent = await http.GetStringAsync("/examples/physics_girl_st.yml");
            }
            catch
            {
                // If HTTP fails, use a simple template instead
                exampleContent = @"bpm: 130
rowsperbeat: 4
score:
    tracks:
        - numvoices: 1
          order: [0]
          patterns:
              - [60, 1, 1, 1, 62, 1, 1, 1, 64, 1, 1, 1, 65, 1, 1, 1]
    rowsperpattern: 16
    length: 1
patch:
    - numvoices: 1
      units:
          - type: envelope
            parameters:
                attack: 16
                decay: 32
                gain: 128
                release: 64
                stereo: 0
                sustain: 96
          - type: oscillator
            parameters:
                color: 64
                detune: 64
                gain: 128
                lfo: 0
                phase: 0
                shape: 64
                stereo: 0
                transpose: 64
                type: 0
                unison: 0
          - type: out
            parameters:
                gain: 64
                stereo: 1
";
            }
            
            string fileName = "example_song.yml";
            
            bool saved = await ProjectFile.SaveSointuSongAsync(CurrentProject.Name, exampleContent, fileName);
            if (saved)
            {
                await LogAsync($"Loaded example song: {fileName}");
                await LoadSongFilesAsync();
                await EditSong(fileName);
            }
            else
            {
                await LogAsync($"Error loading example song");
            }
        }
        catch (Exception ex)
        {
            await LogAsync($"Error loading example: {ex.Message}");
        }
    }
    
    private async Task EditSong(string songFile)
    {
        if (CurrentProject == null) return;
        
        try
        {
            await LogAsync($"Loading song file: {songFile}");
            string? content = await ProjectFile.LoadSointuSongAsync(CurrentProject.Name, songFile);
            if (content == null)
            {
                await LogAsync($"Error: Could not load song file: {songFile}");
                return;
            }
            
            await LogAsync($"Loaded song file: {songFile} ({content.Length} characters)");
            
            editingSong = songFile;
            editingContent = content;
            pendingEditSong = songFile;
            
            // Trigger DOM update - editor will be initialized in OnAfterRenderAsync
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await LogAsync($"Error loading song for editing: {ex.Message}");
            await LogAsync($"Stack trace: {ex.StackTrace}");
        }
    }
    
    private async Task InitializeEditorAsync()
    {
        if (editingSong == null || editingContent == null)
        {
            await LogAsync($"Warning: InitializeEditorAsync called but editingSong={editingSong}, editingContent is {(editingContent == null ? "null" : "not null")}");
            return;
        }
        
        try
        {
            await LogAsync($"Initializing editor for: {editingSong} (content length: {editingContent.Length})");
            
            // Ensure CodeMirror is initialized
            await CodeEditor.InitializeAsync();
            
            // Always destroy existing editor before creating a new one
            if (editorInitialized)
            {
                await LogAsync("Destroying existing editor before creating new one");
                try
                {
                    await CodeEditor.DestroyEditorAsync("song-editor");
                }
                catch (Exception ex)
                {
                    await LogAsync($"Warning: Error destroying editor: {ex.Message}");
                }
                editorInitialized = false;
                editorCallbackRef?.Dispose();
                editorCallbackRef = null;
            }
            
            // Also check if editor exists in JavaScript (in case our state is out of sync)
            bool jsEditorExists = await JSRuntime.InvokeAsync<bool>("eval", 
                "window.monacoLoader && window.monacoLoader.editors && window.monacoLoader.editors.has('song-editor')");
            
            if (jsEditorExists)
            {
                await LogAsync("Found existing editor in JavaScript, destroying it");
                await CodeEditor.DestroyEditorAsync("song-editor");
            }
            
            // Additional wait to ensure DOM element is fully rendered
            await Task.Delay(100);
            
            // Verify container exists and is visible via JavaScript
            bool containerReady = await JSRuntime.InvokeAsync<bool>("eval", 
                @"(function() {
                    const el = document.getElementById('song-editor');
                    return el !== null && el.offsetParent !== null;
                })()");
            
            if (!containerReady)
            {
                await LogAsync("Error: song-editor container not found or not visible in DOM");
                return;
            }
            
            await LogAsync("Container found and visible, creating editor...");
            
            editorCallbackRef = DotNetObjectReference.Create(new CodeEditorCallback(async (value) =>
            {
                editingContent = value;
                await InvokeAsync(StateHasChanged);
            }));
            
            await LogAsync($"Creating CodeMirror editor with content length: {editingContent.Length}");
            await CodeEditor.CreateEditorAsync("song-editor", "yaml", editingContent, editorCallbackRef);
            editorInitialized = true;
            
            // Refresh editor to ensure proper rendering
            await Task.Delay(200);
            await CodeEditor.RefreshEditorAsync("song-editor");
            
            // Verify content was set
            string? verifyContent = await CodeEditor.GetValueAsync("song-editor");
            await LogAsync($"Editor created. Content length in editor: {(verifyContent?.Length ?? 0)}");
            
            if (string.IsNullOrEmpty(verifyContent))
            {
                await LogAsync("Warning: Editor created but content is empty. Attempting to set value again...");
                await CodeEditor.SetValueAsync("song-editor", editingContent);
                await Task.Delay(100);
                await CodeEditor.RefreshEditorAsync("song-editor");
                verifyContent = await CodeEditor.GetValueAsync("song-editor");
                await LogAsync($"After retry, content length: {(verifyContent?.Length ?? 0)}");
            }
            
            // Force state update to ensure UI reflects changes
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await LogAsync($"Error initializing editor: {ex.Message}");
            await LogAsync($"Stack trace: {ex.StackTrace}");
        }
    }
    
    private async Task SaveSong()
    {
        if (CurrentProject == null || editingSong == null) return;
        
        try
        {
            string content = await CodeEditor.GetValueAsync("song-editor");
            bool saved = await ProjectFile.SaveSointuSongAsync(CurrentProject.Name, content, editingSong);
            
            if (saved)
            {
                await LogAsync($"Saved song: {editingSong}");
                editingSong = null;
                editingContent = null;
                await LoadSongFilesAsync();
                StateHasChanged();
            }
            else
            {
                await LogAsync($"Error saving song: {editingSong}");
            }
        }
        catch (Exception ex)
        {
            await LogAsync($"Error saving song: {ex.Message}");
        }
    }
    
    private void CancelEdit()
    {
        editingSong = null;
        editingContent = null;
        pendingEditSong = null;
        StateHasChanged();
    }
    
    private async Task DeleteSong(string songFile)
    {
        if (CurrentProject == null) return;
        
        // Simple confirmation (could be improved with a modal)
        bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", 
            $"Are you sure you want to delete '{songFile}'?");
        
        if (!confirmed) return;
        
        bool deleted = await ProjectFile.DeleteSointuSongAsync(CurrentProject.Name, songFile);
        if (deleted)
        {
            await LogAsync($"Deleted song: {songFile}");
            if (editingSong == songFile)
            {
                editingSong = null;
                editingContent = null;
            }
            await LoadSongFilesAsync();
        }
        else
        {
            await LogAsync($"Error deleting song: {songFile}");
        }
    }
    
    private async Task LogAsync(string message)
    {
        if (OnLog.HasDelegate)
        {
            await OnLog.InvokeAsync(message);
        }
    }
}

<style>
.sointu-song-manager {
    position: fixed;
    top: 0;
    right: -500px;
    width: 500px;
    height: 100vh;
    background: #252526;
    border-left: 1px solid #3e3e3e;
    z-index: 1050;
    transition: right 0.3s ease;
    display: flex;
    flex-direction: column;
    box-shadow: -2px 0 10px rgba(0, 0, 0, 0.5);
}

.sointu-song-manager.visible {
    right: 0;
}

.song-manager-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    border-bottom: 1px solid #3e3e3e;
    background: #1e1e1e;
}

.song-manager-header h5 {
    margin: 0;
    color: #d4d4d4;
    font-size: 1.1rem;
}

.btn-close {
    background: none;
    border: none;
    color: #d4d4d4;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    line-height: 1;
}

.btn-close:hover {
    color: #fff;
    background: #3e3e3e;
    border-radius: 4px;
}

.song-manager-content {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
}

.song-manager-section {
    margin-bottom: 20px;
}

.song-manager-section h6 {
    color: #4ec9b0;
    margin-bottom: 10px;
}

.monaco-editor-container {
    border: 1px solid #3e3e3e;
    border-radius: 4px;
    background: #1e1e1e;
}

/* CodeMirror editor styles are in shared css/code-editor.css */

.list-group-item {
    background: #1e1e1e;
    border: 1px solid #3e3e3e;
    color: #d4d4d4;
}

.list-group-item.active {
    background: #0e639c;
    border-color: #1177bb;
}

.list-group-item:hover {
    background: #2d2d30;
}

.alert {
    border-radius: 4px;
    padding: 12px;
    margin-bottom: 15px;
}

.alert-warning {
    background: #3e3e00;
    border: 1px solid #6e6e00;
    color: #ffcc00;
}

.alert-info {
    background: #1e3a5f;
    border: 1px solid #3e5f8f;
    color: #569cd6;
}
</style>

