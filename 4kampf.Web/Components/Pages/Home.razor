@page "/"
@using _4kampf.Shared.Models
@using _4kampf.Shared.Utilities
@inject WebGLService WebGL
@inject WebAudioService WebAudio
@inject ProjectService ProjectService
@inject CodeEditorService CodeEditor
@inject CameraService Camera
@inject SointuService Sointu
@inject SointuWasmService SointuWasm
@inject MusicEnvelopeService MusicEnvelope
@inject ProjectFileService ProjectFile
@inject ProjectImportExportService ImportExport
@inject IHttpClientFactory HttpClientFactory
@inject IWebHostEnvironment WebHostEnvironment
@inject IJSRuntime _jsRuntime
@implements IAsyncDisposable
@rendermode InteractiveServer

<PageTitle>4kampf - Web Edition</PageTitle>

<div class="app-container">
    <div class="menu-bar">
        <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
            <div class="container-fluid">
                <a class="navbar-brand" href="#">4kampf</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarNav">
                    <ul class="navbar-nav">
                        <li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle" href="#" id="fileDropdown" role="button" data-bs-toggle="dropdown">
                                File
                            </a>
                            <ul class="dropdown-menu">
                                <li><a class="dropdown-item" href="#" @onclick="CreateNew" @onclick:preventDefault="true">New</a></li>
                                <li><a class="dropdown-item" href="#" @onclick="OpenProject" @onclick:preventDefault="true">Open</a></li>
                                <li><a class="dropdown-item" href="#" @onclick="SaveAll" @onclick:preventDefault="true">Save All</a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><a class="dropdown-item" href="#" @onclick="ImportProject" @onclick:preventDefault="true">Import from .kml...</a></li>
                                <li><a class="dropdown-item" href="#" @onclick="ExportProject" @onclick:preventDefault="true">Export to VS...</a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><a class="dropdown-item" href="#" @onclick="ShowGitOperations" @onclick:preventDefault="true">Git Operations...</a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><a class="dropdown-item" href="#" @onclick="ManageSointuSong" @onclick:preventDefault="true">Manage Sointu Song...</a></li>
                            </ul>
                        </li>
                        <li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle" href="#" id="buildDropdown" role="button" data-bs-toggle="dropdown">
                                Build
                            </a>
                            <ul class="dropdown-menu">
                                <li><a class="dropdown-item" href="#" @onclick="RebuildShadersAction" @onclick:preventDefault="true">Rebuild Shaders</a></li>
                                <li><a class="dropdown-item" href="#" @onclick="RenderMusic" @onclick:preventDefault="true">Render Music</a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><a class="dropdown-item" href="#" @onclick="DoBuild" @onclick:preventDefault="true">Build</a></li>
                                <li><a class="dropdown-item" href="#" @onclick="Run" @onclick:preventDefault="true">Run</a></li>
                            </ul>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#" @onclick="ToggleSettings" @onclick:preventDefault="true">
                                Settings
                                @if (settingsVisible)
                                {
                                    <span class="badge bg-primary">●</span>
                                }
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
    </div>
    
    <Toolbar @ref="toolbar"
             OnNew="CreateNew"
             OnOpen="OpenProject"
             OnSave="SaveAll"
             OnUndo="UndoAction"
             OnRedo="RedoAction"
             OnFind="FindAction"
             OnToggleLineNumbers="ToggleLineNumbers"
             OnToggleStandardUniforms="ToggleStandardUniforms"
             OnToggleEnvelopes="ToggleEnvelopes"
             OnToggleCamera="ToggleCamera"
             OnBuild="DoBuild"
             OnRun="Run"
             OnRenderMusic="RenderMusic"
             OnScreenshot="ScreenshotAction"
             OnColorHelper="ColorHelperAction"
             OnFullscreen="FullscreenAction"
             OnFreefly="FreeflyAction"
             OnLockfly="LockflyAction"
             OnResetCamera="ResetCameraAction"
             CanUndo="@canUndo"
             CanRedo="@canRedo"
             ShowLineNumbers="@showLineNumbers"
             EnableStandardUniforms="@enableStandardUniforms"
             EnableEnvelopeSync="@enableEnvelopeSync"
             EnableCamControls="@enableCamControls"
             CameraMode="@cameraMode" />
    
    <div class="status-bar">
        <div class="status-item">
            <span class="status-label">Sointu:</span>
            @if (Sointu.IsAvailable)
            {
                <span class="status-badge status-success">✓</span>
            }
            else
            {
                <span class="status-badge status-error">✗</span>
            }
        </div>
        <div class="status-item">
            <span class="status-label">WASM:</span>
            @if (SointuWasm.IsAvailable)
            {
                <span class="status-badge status-success">✓</span>
            }
            else
            {
                <span class="status-badge status-neutral">—</span>
            }
        </div>
        <div class="status-item">
            <span class="status-label">Envelopes:</span>
            @if (MusicEnvelope.HasEnvelopes)
            {
                <span class="status-badge status-success">@MusicEnvelope.NumInstruments</span>
            }
            else
            {
                <span class="status-badge status-neutral">—</span>
            }
        </div>
        <div class="status-item">
            <span class="status-label">Camera:</span>
            <span class="status-badge @(enableCamControls ? "status-success" : "status-neutral")">
                @(enableCamControls ? "ON" : "OFF")
            </span>
        </div>
        <div class="status-item">
            <span class="status-label">Uniforms:</span>
            <span class="status-badge @(enableStandardUniforms ? "status-success" : "status-neutral")">
                @(enableStandardUniforms ? "ON" : "OFF")
            </span>
        </div>
    </div>

    <div class="main-content">
        <div class="left-panel">
            <div class="shader-editor">
                <ul class="nav nav-tabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="vert-tab" data-bs-toggle="tab" data-bs-target="#vert" type="button" role="tab">
                            Vertex
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="frag-tab" data-bs-toggle="tab" data-bs-target="#frag" type="button" role="tab">
                            Fragment
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="post-tab" data-bs-toggle="tab" data-bs-target="#post" type="button" role="tab">
                            Post-Process
                        </button>
                    </li>
                </ul>
                <div class="tab-content">
                    <div class="tab-pane fade show active" id="vert" role="tabpanel">
                        <div id="vert-editor" class="monaco-editor-container"></div>
                    </div>
                    <div class="tab-pane fade" id="frag" role="tabpanel">
                        <div id="frag-editor" class="monaco-editor-container"></div>
                    </div>
                    <div class="tab-pane fade" id="post" role="tabpanel">
                        <div id="post-editor" class="monaco-editor-container"></div>
                    </div>
                </div>
            </div>
            <div class="log-panel">
                <div class="log-header">
                    <span>Log</span>
                    <button class="btn btn-sm btn-secondary" @onclick="ClearLog">Clear</button>
                </div>
                <div class="log-content">
                    @foreach (var logEntry in logEntries)
                    {
                        <div class="log-entry">@logEntry</div>
                    }
                </div>
            </div>
        </div>

        <div class="right-panel">
            <div class="preview-container">
                <canvas id="preview-canvas" @ref="previewCanvas" width="1280" height="720" 
                        tabindex="0"></canvas>
            </div>
            <div class="music-player-container">
                <MusicPlayerComponent @ref="musicPlayer" 
                                     OnPlayPause="OnMusicPlayerPlayPause"
                                     IsWasmMode="@(currentProject?.UseWasmRendering ?? false)"
                                     IsMusicReady="@isMusicReady" />
            </div>
        </div>
    </div>
    
    <SettingsPanel @bind-IsVisible="settingsVisible"
                   @bind-EnableStandardUniforms="enableStandardUniforms"
                   @bind-EnableCamControls="enableCamControls"
                   @bind-EnableEnvelopeSync="enableEnvelopeSync"
                   @bind-SelectedSynth="selectedSynth"
                   @bind-UseWasmRendering="useWasmRendering"
                   @bind-UsePostProcess="usePostProcess"
                   @bind-UseVertexShader="useVertexShader"
                   @bind-EnableLooping="enableLooping" />
    
    <SointuSongManager @ref="songManager"
                      CurrentProject="@currentProject"
                      ProjectChanged="OnProjectChanged"
                      OnLog="AddLog" />
    
    <ProjectImportExportDialog @ref="importExportDialog"
                              CurrentProject="@currentProject"
                              ProjectImported="OnProjectImported"
                              OnLog="AddLog" />
    
    <GitOperationsDialog @ref="gitOperationsDialog"
                        CurrentProject="@currentProject"
                        OnProjectUpdated="OnProjectUpdated"
                        OnLog="AddLog" />
    
    <ColorHelper @ref="colorHelper"
                OnColorSelected="OnColorSelected"
                OnReplace="OnColorReplace" />
    
    <RenderingProgressDialog @ref="renderingProgressDialog" />
</div>

@code {
    private ElementReference previewCanvas;
    private MusicPlayerComponent? musicPlayer;
    private SointuSongManager? songManager;
    private ProjectImportExportDialog? importExportDialog;
    private GitOperationsDialog? gitOperationsDialog;
    private Toolbar? toolbar;
    private ColorHelper? colorHelper;
    private RenderingProgressDialog? renderingProgressDialog;
    
    private bool canUndo = false;
    private bool canRedo = false;
    private bool showLineNumbers = true;
    private string cameraMode = "freefly";
    private bool isMusicPlaying = false;
    
    private async Task OnMusicPlayerPlayPause(bool isPlaying)
    {
        isMusicPlaying = isPlaying;
        // Also control shader rendering if needed
        // The render loop should already be running, but we can pause/resume it if needed
    }
    
    private string vertexShaderCode = "";
    private string fragmentShaderCode = "";
    private string postProcessShaderCode = "";
    
    private List<string> logEntries = new();
    private string? sceneProgramId;
    private string? postProcessProgramId;
    private bool isRendering = false;
    private bool enableCamControls = true;
    private bool enableStandardUniforms = true;
    private bool enableEnvelopeSync = false; // Enable when music with envelopes is loaded
    private bool shiftPressed = false;
    private bool settingsVisible = false;
    private string selectedSynth = "sointu";
    private Project? currentProject;
    private string currentProjectName = "Untitled Project";
    private bool usePostProcess = true;
    private bool useVertexShader = true;
    private bool enableLooping = false;
    private bool useWasmRendering = true; // Default to WASM rendering
    private DotNetObjectReference<CodeEditorCallback>? vertCallbackRef;
    private DotNetObjectReference<CodeEditorCallback>? fragCallbackRef;
    private DotNetObjectReference<CodeEditorCallback>? postCallbackRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // Wait a bit to ensure canvas is rendered
                await Task.Delay(100);
                await WebGL.InitializeAsync("preview-canvas");
                await WebAudio.InitializeAsync();
                var cameraId = await Camera.InitializeAsync("preview-canvas");
                await CodeEditor.InitializeAsync();
                
                // Initialize canvas event handlers
                await _jsRuntime.InvokeVoidAsync("canvasEvents.init", "preview-canvas", cameraId);
                
                AddLog("Initialized WebGL, WebAudio, Camera, and Code Editor");
                
                // Check Sointu availability (server-side)
                if (Sointu.IsAvailable)
                {
                    AddLog("✓ Sointu (server-side) is available");
                }
                else
                {
                    AddLog("⚠ Sointu (server-side) is not available");
                    AddLog("See README_SOINTU.md for installation instructions");
                }
                
                // Initialize Sointu WASM (client-side)
                AddLog("Initializing Sointu WebAssembly...");
                bool wasmInitialized = await SointuWasm.InitializeAsync("/wasm/sointu.wasm");
                if (wasmInitialized)
                {
                    AddLog("✓ Sointu WebAssembly initialized successfully");
                }
                else
                {
                    AddLog("⚠ Sointu WebAssembly not available - using server-side rendering");
                    AddLog("Note: WASM module not found at /wasm/sointu.wasm");
                }
                
                // Load default sample project
                await LoadDefaultProject();
                
                // Wait a bit more for CodeMirror to be ready
                await Task.Delay(500);
                
                // Initialize CodeMirror editors
                await InitializeEditors();
            }
            catch (Exception ex)
            {
                AddLog($"Error initializing: {ex.Message}");
                AddLog($"Stack trace: {ex.StackTrace}");
            }
        }
    }

    private async Task InitializeEditors()
    {
        try
        {
            // Create callbacks for shader updates (debounced)
            vertCallbackRef = DotNetObjectReference.Create(new CodeEditorCallback(async (value) =>
            {
                vertexShaderCode = value;
                await RebuildShaders();
            }));
            
            fragCallbackRef = DotNetObjectReference.Create(new CodeEditorCallback(async (value) =>
            {
                fragmentShaderCode = value;
                await RebuildShaders();
            }));
            
            postCallbackRef = DotNetObjectReference.Create(new CodeEditorCallback(async (value) =>
            {
                postProcessShaderCode = value;
                await RebuildShaders();
            }));
            
            // Create editors with initial shader code
            await CodeEditor.CreateEditorAsync("vert-editor", "glsl", vertexShaderCode, vertCallbackRef);
            await CodeEditor.CreateEditorAsync("frag-editor", "glsl", fragmentShaderCode, fragCallbackRef);
            await CodeEditor.CreateEditorAsync("post-editor", "glsl", postProcessShaderCode, postCallbackRef);
            
            AddLog("Code editors initialized");
            
            // Compile and build shaders after editors are ready
            await Task.Delay(200);
            await RebuildShaders();
        }
        catch (Exception ex)
        {
            AddLog($"Error initializing editors: {ex.Message}");
        }
    }

    private async Task LoadDefaultProject()
    {
        try
        {
            AddLog("Loading default sample project...");
            
            // Create or get the default project
            if (currentProject == null)
            {
                currentProject = ProjectFile.CreateNewProject("Default Project");
                currentProjectName = currentProject.Name;
            }
            
            // Load default shaders
            vertexShaderCode = ProjectService.DefaultVertexShader;
            fragmentShaderCode = ProjectService.DefaultFragmentShader;
            postProcessShaderCode = ProjectService.DefaultPostProcessShader;
            
            // Update project with shaders
            currentProject.VertexShader = vertexShaderCode;
            currentProject.FragmentShader = fragmentShaderCode;
            currentProject.PostProcessShader = postProcessShaderCode;
            
            // Set default Sointu song to physics_girl_st.yml
            string defaultSongFile = "physics_girl_st.yml";
            currentProject.SointuSongFile = defaultSongFile;
            
            // Load the example song content and save it to the project
            try
            {
                // Read the file directly from wwwroot/examples
                string exampleFilePath = Path.Combine(WebHostEnvironment.WebRootPath, "examples", defaultSongFile);
                
                if (File.Exists(exampleFilePath))
                {
                    string songContent = await File.ReadAllTextAsync(exampleFilePath);
                    
                    // Save the song file to the project directory
                    bool saved = await ProjectFile.SaveSointuSongAsync(currentProject.Name, songContent, defaultSongFile);
                    if (saved)
                    {
                        AddLog($"Default song file '{defaultSongFile}' loaded successfully");
                    }
                    else
                    {
                        AddLog($"Warning: Could not save default song file '{defaultSongFile}'");
                    }
                }
                else
                {
                    AddLog($"Warning: Example song file not found at '{exampleFilePath}'");
                    // Continue without the song file - user can load it later
                }
            }
            catch (Exception ex)
            {
                AddLog($"Warning: Could not load example song '{defaultSongFile}': {ex.Message}");
                // Continue without the song file - user can load it later
            }
            
            // Save the project
            await ProjectFile.SaveProjectAsync(currentProject);
            
            StateHasChanged();
            
            AddLog("Default sample project loaded successfully!");
        }
        catch (Exception ex)
        {
            AddLog($"Error loading default project: {ex.Message}");
        }
    }

    private async Task RebuildShaders()
    {
        try
        {
            AddLog("Rebuilding shaders...");
            
            // Compile vertex shader
            string? vsId = await WebGL.CreateShaderAsync(35633, vertexShaderCode); // GL_VERTEX_SHADER
            if (vsId == null)
            {
                AddLog("Error: Failed to compile vertex shader");
                return;
            }
            
            // Compile fragment shader
            string? fsId = await WebGL.CreateShaderAsync(35632, fragmentShaderCode); // GL_FRAGMENT_SHADER
            if (fsId == null)
            {
                AddLog("Error: Failed to compile fragment shader");
                return;
            }
            
            // Create scene program
            sceneProgramId = await WebGL.CreateProgramAsync(vsId, fsId);
            if (sceneProgramId == null)
            {
                AddLog("Error: Failed to link scene program");
                return;
            }
            
            // Compile post-process shader if we have one
            if (!string.IsNullOrWhiteSpace(postProcessShaderCode))
            {
                string? ppFsId = await WebGL.CreateShaderAsync(35632, postProcessShaderCode);
                if (ppFsId != null)
                {
                    // Post-process uses a simple pass-through vertex shader
                    string? ppVsId = await WebGL.CreateShaderAsync(35633, 
                        "#version 300 es\nprecision mediump float;\nin vec2 a_position; out vec2 uv; void main() { gl_Position = vec4(a_position, 0.0, 1.0); uv = (a_position + 1.0) / 2.0; }");
                    if (ppVsId != null)
                    {
                        postProcessProgramId = await WebGL.CreateProgramAsync(ppVsId, ppFsId);
                    }
                }
            }
            
            AddLog("Shaders compiled successfully!");
            
            // Start rendering loop
            if (!isRendering)
            {
                isRendering = true;
                _ = Task.Run(async () => await RenderLoop());
            }
        }
        catch (Exception ex)
        {
            AddLog($"Error rebuilding shaders: {ex.Message}");
        }
    }

    private async Task RenderLoop()
    {
        while (isRendering)
        {
            try
            {
                if (sceneProgramId != null)
                {
                    // Update camera
                    if (enableCamControls)
                    {
                        await Camera.UpdateAsync(shiftPressed);
                    }
                    
                    await WebGL.UseProgramAsync(sceneProgramId);
                    
                    // Set viewport
                    await WebGL.SetViewportAsync(0, 0, 1280, 720);
                    
                    // Set uniforms (time, resolution, camera)
                    float time = (float)(DateTime.Now - DateTime.Today).TotalSeconds;
                    
                    if (enableStandardUniforms)
                    {
                        await WebGL.SetUniform3fAsync(sceneProgramId, "u", 1280f, 720f, time);
                    }
                    
                    if (enableCamControls)
                    {
                        var (cx, cy, cz) = await Camera.GetPositionAsync();
                        var (rx, ry, rz) = await Camera.GetRotationAsync();
                        await WebGL.SetUniform3fAsync(sceneProgramId, "cp", cx, cy, cz);
                        await WebGL.SetUniform3fAsync(sceneProgramId, "cr", rx, ry, rz);
                    }
                    
                    // Set envelope sync uniforms if available and enabled
                    if (enableEnvelopeSync && MusicEnvelope.HasEnvelopes && musicPlayer != null)
                    {
                        try
                        {
                            double currentPos = await WebAudio.GetPositionAsync();
                            float[]? envelopeSync = MusicEnvelope.GetEnvelopeSync(currentPos);
                            if (envelopeSync != null && envelopeSync.Length > 0)
                            {
                                // Pass envelope values to shader as uniform array
                                // Shader expects: uniform float ev[MAX_INSTRUMENTS];
                                await WebGL.SetUniform1fvAsync(sceneProgramId, "ev", envelopeSync);
                            }
                        }
                        catch
                        {
                            // Silently ignore envelope errors
                        }
                    }
                    
                    // Clear and render
                    await WebGL.ClearAsync(0f, 0f, 0f, 1f);
                    await WebGL.RenderQuadAsync();
                }
                
                await Task.Delay(16); // ~60 FPS
            }
            catch (Exception)
            {
                // Silently handle errors in render loop
                await Task.Delay(100);
            }
        }
    }


    private async Task RebuildShadersAction()
    {
        await RebuildShaders();
    }

    private async Task CreateNew()
    {
        try
        {
            currentProject = ProjectFile.CreateNewProject("New Project");
            currentProjectName = currentProject.Name;
            
            // Load default shaders
            vertexShaderCode = ProjectService.DefaultVertexShader;
            fragmentShaderCode = ProjectService.DefaultFragmentShader;
            postProcessShaderCode = ProjectService.DefaultPostProcessShader;
            
            // Update UI state from project
            selectedSynth = currentProject.Synth.ToStringIdentifier();
            enableStandardUniforms = currentProject.EnableStandardUniforms;
            enableCamControls = currentProject.EnableCamControls;
            enableEnvelopeSync = currentProject.EnableEnvelopeSync;
            usePostProcess = currentProject.UsePostProcess;
            useVertexShader = currentProject.UseVertexShader;
            enableLooping = currentProject.EnableLooping;
            
            // Update editors
            await CodeEditor.SetValueAsync("vert-editor", vertexShaderCode);
            await CodeEditor.SetValueAsync("frag-editor", fragmentShaderCode);
            await CodeEditor.SetValueAsync("post-editor", postProcessShaderCode);
            
            AddLog("New project created");
        }
        catch (Exception ex)
        {
            AddLog($"Error creating project: {ex.Message}");
        }
    }
    
    private async Task OpenProject()
    {
        try
        {
            // For now, just log - in a real implementation, this would show a file picker
            AddLog("Open Project - File picker not yet implemented");
            AddLog("Projects are stored in wwwroot/projects/");
            
            // List available projects
            var projects = await ProjectFile.ListProjectsAsync();
            if (projects.Any())
            {
                AddLog("Available projects:");
                foreach (var project in projects)
                {
                    AddLog($"  - {project}");
                }
            }
            else
            {
                AddLog("No projects found");
            }
        }
        catch (Exception ex)
        {
            AddLog($"Error opening project: {ex.Message}");
        }
    }
    
    private async Task OnProjectChanged(Project updatedProject)
    {
        currentProject = updatedProject;
        await ProjectFile.SaveProjectAsync(currentProject);
        StateHasChanged();
    }
    
    private async Task SaveAll()
    {
        try
        {
            if (currentProject == null)
            {
                currentProject = ProjectFile.CreateNewProject(currentProjectName);
            }
            
            // Update project with current shader code
            currentProject.VertexShader = await CodeEditor.GetValueAsync("vert-editor");
            currentProject.FragmentShader = await CodeEditor.GetValueAsync("frag-editor");
            currentProject.PostProcessShader = await CodeEditor.GetValueAsync("post-editor");
            
            // Update project settings
            currentProject.EnableStandardUniforms = enableStandardUniforms;
            currentProject.EnableCamControls = enableCamControls;
            currentProject.EnableEnvelopeSync = enableEnvelopeSync;
            // Convert string to enum
            currentProject.Synth = selectedSynth.ToSynthEnum();
            
            bool saved = await ProjectFile.SaveProjectAsync(currentProject);
            if (saved)
            {
                AddLog("Project saved successfully");
            }
            else
            {
                AddLog("Error: Failed to save project");
            }
        }
        catch (Exception ex)
        {
            AddLog($"Error saving project: {ex.Message}");
        }
    }
    
    private async Task ManageSointuSong()
    {
        try
        {
            if (currentProject == null)
            {
                currentProject = ProjectFile.CreateNewProject(currentProjectName);
            }
            
            // Ensure project is saved with current state
            await ProjectFile.SaveProjectAsync(currentProject);
            
            // Show the song manager
            if (songManager != null)
            {
                songManager.Show();
            }
            else
            {
                AddLog("Song manager not available");
            }
        }
        catch (Exception ex)
        {
            AddLog($"Error managing Sointu song: {ex.Message}");
        }
    }
    
    private void ImportProject()
    {
        if (importExportDialog != null)
        {
            importExportDialog.Show();
        }
        else
        {
            AddLog("Import/Export dialog not available");
        }
    }
    
    private void ExportProject()
    {
        if (importExportDialog != null)
        {
            importExportDialog.Show();
        }
        else
        {
            AddLog("Import/Export dialog not available");
        }
    }
    
    private void ShowGitOperations()
    {
        if (gitOperationsDialog != null)
        {
            gitOperationsDialog.Show();
        }
        else
        {
            AddLog("Git operations dialog not available");
        }
    }
    
    private async Task OnProjectUpdated()
    {
        // Reload project after Git pull
        if (currentProject != null)
        {
            var projectPath = $"{currentProject.Name}/{currentProject.Name}.json";
            var reloadedProject = await ProjectFile.LoadProjectAsync(projectPath);
            if (reloadedProject != null)
            {
                currentProject = reloadedProject;
                currentProjectName = reloadedProject.Name;
                
                // Reload shaders
                vertexShaderCode = currentProject.VertexShader;
                fragmentShaderCode = currentProject.FragmentShader;
                postProcessShaderCode = currentProject.PostProcessShader;
                
                // Update UI state
                enableStandardUniforms = currentProject.EnableStandardUniforms;
                enableCamControls = currentProject.EnableCamControls;
                enableEnvelopeSync = currentProject.EnableEnvelopeSync;
                usePostProcess = currentProject.UsePostProcess;
                useVertexShader = currentProject.UseVertexShader;
                enableLooping = currentProject.EnableLooping;
                useWasmRendering = currentProject.UseWasmRendering;
                selectedSynth = currentProject.Synth.ToString().ToLower();
                
                // Rebuild shaders
                await RebuildShadersAction();
                
                AddLog("Project reloaded after Git pull");
            }
        }
    }
    
    private async Task OnProjectImported(Project project)
    {
        currentProject = project;
        currentProjectName = project.Name;
        
        // Load shaders from project
        vertexShaderCode = project.VertexShader;
        fragmentShaderCode = project.FragmentShader;
        postProcessShaderCode = project.PostProcessShader;
        
        // Update UI state
        enableStandardUniforms = project.EnableStandardUniforms;
        enableCamControls = project.EnableCamControls;
        enableEnvelopeSync = project.EnableEnvelopeSync;
        usePostProcess = project.UsePostProcess;
        useVertexShader = project.UseVertexShader;
        enableLooping = project.EnableLooping;
        useWasmRendering = project.UseWasmRendering;
        
        selectedSynth = project.Synth.ToString().ToLower();
        
        // Save imported project
        await ProjectFile.SaveProjectAsync(currentProject);
        
        AddLog($"Project imported: {project.Name}");
        
        // Rebuild shaders
        await RebuildShadersAction();
    }
    
    private async Task RenderMusic()
    {
        try
        {
            AddLog("Rendering music...");
            
            // Ensure we have a project
            if (currentProject == null)
            {
                currentProject = ProjectFile.CreateNewProject(currentProjectName);
            }
            
            // Prefer WASM rendering when available (default and recommended)
            if (SointuWasm.IsAvailable)
            {
                // WASM is available - use it (preferred method)
                AddLog("Using WebAssembly rendering (client-side)...");
                
                // Update project setting to prefer WASM if not already set
                if (!currentProject.UseWasmRendering)
                {
                    currentProject.UseWasmRendering = true;
                    useWasmRendering = true;
                    await ProjectFile.SaveProjectAsync(currentProject);
                }
                
                await RenderMusicWasm();
            }
            else if (currentProject.UseWasmRendering)
            {
                // WASM was requested but not available - try server-side
                AddLog("WASM rendering requested but not available. Trying server-side rendering...");
                await RenderMusicServer();
            }
            else
            {
                // Use server-side rendering
                AddLog("Using server-side rendering...");
                await RenderMusicServer();
            }
        }
        catch (Exception ex)
        {
            AddLog($"Error rendering music: {ex.Message}");
            AddLog($"Stack trace: {ex.StackTrace}");
        }
    }
    
    private bool isMusicReady = false;
    
    private async Task RenderMusicWasm()
    {
        try
        {
            // Show progress dialog
            if (renderingProgressDialog != null)
            {
                renderingProgressDialog.Show();
                await InvokeAsync(StateHasChanged);
            }
            
            AddLog("Using WebAssembly rendering (client-side)...");
            
            // Ensure we have a project
            if (currentProject == null)
            {
                AddLog("Error: No project loaded");
                if (renderingProgressDialog != null)
                {
                    renderingProgressDialog.Hide();
                }
                return;
            }
            
            // Get Sointu song file content
            string? songYamlContent = null;
            if (!string.IsNullOrEmpty(currentProject.SointuSongFile))
            {
                songYamlContent = await ProjectFile.LoadSointuSongAsync(currentProject.Name, currentProject.SointuSongFile);
            }
            else
            {
                songYamlContent = await ProjectFile.LoadSointuSongAsync(currentProject.Name, "song.yml");
            }
            
            if (string.IsNullOrEmpty(songYamlContent))
            {
                AddLog("Error: No Sointu song file found.");
                AddLog("Please create or select a Sointu YAML song file first.");
                if (renderingProgressDialog != null)
                {
                    renderingProgressDialog.Hide();
                }
                return;
            }
            
            // Load song into WASM module with progress callback
            AddLog("Loading song into WASM module...");
            
            // Set up progress callback
            Action<int, string> progressCallback = (percent, message) =>
            {
                if (renderingProgressDialog != null)
                {
                    renderingProgressDialog.UpdateProgress(percent, message);
                    // Force UI update on the main thread (fire and forget)
                    _ = InvokeAsync(StateHasChanged);
                }
                AddLog($"[{percent}%] {message}");
            };
            
            bool loaded = await SointuWasm.LoadSongAsync(songYamlContent, progressCallback);
            
            // Hide progress dialog
            if (renderingProgressDialog != null)
            {
                renderingProgressDialog.Hide();
                await InvokeAsync(StateHasChanged);
            }
            
            if (!loaded)
            {
                AddLog("Error: Failed to load song into WASM module");
                return;
            }
            
            // Get number of instruments for envelope sync
            int numInstruments = await SointuWasm.GetNumInstrumentsAsync();
            if (numInstruments > 0)
            {
                enableEnvelopeSync = true;
                currentProject.EnableEnvelopeSync = true;
                AddLog($"Song loaded: {numInstruments} instrument(s)");
            }
            
            // Mark music as ready (but don't auto-play)
            isMusicReady = true;
            AddLog("✓ Song rendered successfully! Click Play to start preview.");
            
            // Save project with updated settings
            await ProjectFile.SaveProjectAsync(currentProject);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            AddLog($"Error in WASM rendering: {ex.Message}");
            if (renderingProgressDialog != null)
            {
                renderingProgressDialog.Hide();
            }
        }
    }
    
    
    private async Task RenderMusicServer()
    {
        try
        {
            AddLog("Using server-side rendering...");
            
            if (!Sointu.IsAvailable)
            {
                AddLog("Error: Sointu (server-side) is not available.");
                AddLog("Please install Sointu or enable WASM rendering.");
                AddLog("See README_SOINTU.md for installation instructions.");
                return;
            }
            
            // Ensure we have a project
            if (currentProject == null)
            {
                AddLog("Error: No project loaded");
                return;
            }
            
            // Get Sointu song file path
            string? songYamlPath = null;
            if (!string.IsNullOrEmpty(currentProject.SointuSongFile))
            {
                songYamlPath = ProjectFile.GetSointuSongPath(currentProject.Name, currentProject.SointuSongFile);
            }
            else
            {
                songYamlPath = ProjectFile.GetSointuSongPath(currentProject.Name, "song.yml");
                if (!await ProjectFile.HasSointuSongAsync(currentProject.Name, "song.yml"))
                {
                    AddLog("Error: No Sointu song file found.");
                    AddLog("Please create or select a Sointu YAML song file first.");
                    return;
                }
            }
            
            // Set up output paths
            string projectDir = ProjectFile.GetProjectDirectory(currentProject.Name);
            string outputAsm = Path.Combine(projectDir, "music.asm");
            string outputWav = Path.Combine(projectDir, "music.wav");
            
            // Compile song to assembly
            AddLog("Compiling song to assembly...");
            bool compiled = await Sointu.CompileSongAsync(songYamlPath, outputAsm);
            if (!compiled)
            {
                AddLog("Error: Failed to compile song");
                return;
            }
            
            // Render to WAV
            AddLog("Rendering audio to WAV...");
            bool rendered = await Sointu.RenderAudioAsync(outputAsm, outputWav);
            if (!rendered)
            {
                AddLog("Error: Failed to render audio");
                return;
            }
            
            // Generate envelope data
            AddLog("Generating envelope data...");
            bool envelopesGenerated = await Sointu.GenerateEnvelopesAsync(songYamlPath, projectDir, 16);
            if (envelopesGenerated)
            {
                AddLog("Envelope generation completed");
            }
            else
            {
                AddLog("Warning: Could not generate envelopes automatically");
            }
            
            // Load envelope data
            AddLog("Loading envelope data...");
            await MusicEnvelope.LoadEnvelopesAsync(projectDir);
            
            if (MusicEnvelope.HasEnvelopes)
            {
                enableEnvelopeSync = true;
                currentProject.EnableEnvelopeSync = true;
                AddLog($"Loaded {MusicEnvelope.NumInstruments} instrument envelope(s)");
            }
            else
            {
                AddLog("No envelope data found");
            }
            
            // Save project with updated settings
            await ProjectFile.SaveProjectAsync(currentProject);
            
            // Load audio into player
            if (musicPlayer != null)
            {
                await musicPlayer.LoadAudio($"/projects/{currentProject.Name}/music.wav");
                AddLog("Music rendered and loaded successfully!");
            }
            else
            {
                AddLog("Music rendered, but player not initialized");
            }
        }
        catch (Exception ex)
        {
            AddLog($"Error in server-side rendering: {ex.Message}");
        }
    }
    
    private void DoBuild() => AddLog("Build");
    private void Run() => AddLog("Run");
    
    // Toolbar handlers
    private async Task UndoAction()
    {
        string activeEditor = GetActiveEditorId();
        if (!string.IsNullOrEmpty(activeEditor))
        {
            await CodeEditor.UndoAsync(activeEditor);
            await UpdateUndoRedoState();
        }
    }
    
    private async Task RedoAction()
    {
        string activeEditor = GetActiveEditorId();
        if (!string.IsNullOrEmpty(activeEditor))
        {
            await CodeEditor.RedoAsync(activeEditor);
            await UpdateUndoRedoState();
        }
    }
    
    private async Task FindAction()
    {
        string activeEditor = GetActiveEditorId();
        if (!string.IsNullOrEmpty(activeEditor))
        {
            await CodeEditor.ShowFindAsync(activeEditor);
        }
    }
    
    private async Task ToggleLineNumbers()
    {
        showLineNumbers = !showLineNumbers;
        await CodeEditor.SetLineNumbersAsync("vert-editor", showLineNumbers);
        await CodeEditor.SetLineNumbersAsync("frag-editor", showLineNumbers);
        await CodeEditor.SetLineNumbersAsync("post-editor", showLineNumbers);
    }
    
    private void ToggleStandardUniforms()
    {
        enableStandardUniforms = !enableStandardUniforms;
        if (currentProject != null)
        {
            currentProject.EnableStandardUniforms = enableStandardUniforms;
        }
    }
    
    private void ToggleEnvelopes()
    {
        enableEnvelopeSync = !enableEnvelopeSync;
        if (currentProject != null)
        {
            currentProject.EnableEnvelopeSync = enableEnvelopeSync;
        }
    }
    
    private void ToggleCamera()
    {
        enableCamControls = !enableCamControls;
        if (currentProject != null)
        {
            currentProject.EnableCamControls = enableCamControls;
        }
    }
    
    private async Task ScreenshotAction()
    {
        try
        {
            // Check if shift is pressed (for JPG)
            bool isJpg = shiftPressed;
            string format = isJpg ? "jpg" : "png";
            
            byte[]? screenshotData = await WebGL.CaptureScreenshotAsync(format);
            if (screenshotData != null)
            {
                string base64 = Convert.ToBase64String(screenshotData);
                string mimeType = isJpg ? "image/jpeg" : "image/png";
                string filename = $"screenshot_{DateTime.Now:yyyyMMddHHmmss}.{(isJpg ? "jpg" : "png")}";
                
                await _jsRuntime.InvokeVoidAsync("downloadFile", filename, 
                    $"data:{mimeType};base64,{base64}", mimeType);
                
                AddLog($"Screenshot saved: {filename}");
            }
            else
            {
                AddLog("Failed to capture screenshot");
            }
        }
        catch (Exception ex)
        {
            AddLog($"Error capturing screenshot: {ex.Message}");
        }
    }
    
    private void ColorHelperAction()
    {
        if (colorHelper == null) return;
        
        // Try to parse selected text as vec3 color
        string? selectedText = GetSelectedText();
        double? r = null, g = null, b = null;
        bool isReplacing = false;
        
        if (!string.IsNullOrEmpty(selectedText))
        {
            // Try to parse vec3(r, g, b) format
            var match = System.Text.RegularExpressions.Regex.Match(
                selectedText, 
                @"vec3\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)",
                System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            
            if (match.Success)
            {
                if (float.TryParse(match.Groups[1].Value, out float rf) &&
                    float.TryParse(match.Groups[2].Value, out float gf) &&
                    float.TryParse(match.Groups[3].Value, out float bf))
                {
                    r = rf;
                    g = gf;
                    b = bf;
                    isReplacing = true;
                }
            }
        }
        
        colorHelper.Show(r, g, b, isReplacing);
    }
    
    private async Task OnColorSelected(string colorValue)
    {
        // Insert color value at cursor position
        string activeEditor = GetActiveEditorId();
        if (!string.IsNullOrEmpty(activeEditor))
        {
            // CodeMirror editor insert text at cursor
            await _jsRuntime.InvokeVoidAsync("monacoLoader.insertText", activeEditor, colorValue);
        }
    }
    
    private async Task OnColorReplace()
    {
        // Replace selected text with color value
        string activeEditor = GetActiveEditorId();
        if (!string.IsNullOrEmpty(activeEditor))
        {
            // Get color from helper and replace selection
            if (colorHelper != null)
            {
                string colorValue = $"vec3({colorHelper.R:F3}, {colorHelper.G:F3}, {colorHelper.B:F3})";
                await _jsRuntime.InvokeVoidAsync("monacoLoader.replaceSelection", activeEditor, colorValue);
            }
        }
    }
    
    private void FullscreenAction()
    {
        _jsRuntime.InvokeVoidAsync("toggleFullscreen", "preview-canvas");
    }
    
    private async Task FreeflyAction()
    {
        cameraMode = "freefly";
        await Camera.SetModeAsync("freefly");
        AddLog("Camera mode: Freefly");
    }
    
    private async Task LockflyAction()
    {
        cameraMode = "lockfly";
        await Camera.SetModeAsync("lockfly");
        AddLog("Camera mode: Lockfly (horizontal only)");
    }
    
    private async Task ResetCameraAction()
    {
        await Camera.ResetAsync();
        AddLog("Camera reset");
    }
    
    private string GetActiveEditorId()
    {
        // Determine which editor tab is active based on Bootstrap tab state
        // Check which tab button has 'active' class
        return "frag-editor"; // Default to fragment shader - TODO: track active tab
    }
    
    private string? GetSelectedText()
    {
        // Get selected text from active CodeMirror editor
        // This would need JavaScript interop
        return null;
    }
    
    private async Task UpdateUndoRedoState()
    {
        string activeEditor = GetActiveEditorId();
        if (!string.IsNullOrEmpty(activeEditor))
        {
            canUndo = await CodeEditor.CanUndoAsync(activeEditor);
            canRedo = await CodeEditor.CanRedoAsync(activeEditor);
            StateHasChanged();
        }
    }
    private void ClearLog() => logEntries.Clear();
    
    private void ToggleSettings()
    {
        settingsVisible = !settingsVisible;
    }
    
    private async Task OnStandardUniformsChanged(bool value)
    {
        enableStandardUniforms = value;
        AddLog($"Standard uniforms: {(value ? "enabled" : "disabled")}");
        await Task.CompletedTask;
    }
    
    private async Task OnCamControlsChanged(bool value)
    {
        enableCamControls = value;
        AddLog($"Camera controls: {(value ? "enabled" : "disabled")}");
        await Task.CompletedTask;
    }
    
    private async Task OnEnvelopeSyncChanged(bool value)
    {
        enableEnvelopeSync = value;
        AddLog($"Envelope sync: {(value ? "enabled" : "disabled")}");
        await Task.CompletedTask;
    }
    
    private async Task OnSynthChanged(string value)
    {
        selectedSynth = value;
        AddLog($"Synthesizer changed to: {value}");
        await Task.CompletedTask;
    }
    
    private async Task OnUseWasmRenderingChanged(bool value)
    {
        useWasmRendering = value;
        if (currentProject != null)
        {
            currentProject.UseWasmRendering = value;
            await ProjectFile.SaveProjectAsync(currentProject);
        }
        AddLog($"WASM rendering: {(value ? "enabled" : "disabled")}");
    }

    private void AddLog(string message)
    {
        logEntries.Add($"[{DateTime.Now:HH:mm:ss}] {message}");
        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        isRendering = false;
        vertCallbackRef?.Dispose();
        fragCallbackRef?.Dispose();
        postCallbackRef?.Dispose();
        await Task.CompletedTask;
    }
}

<style>
    .app-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        width: 100vw;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #1e1e1e;
        color: #d4d4d4;
        z-index: 1000;
    }

    .menu-bar {
        flex-shrink: 0;
    }
    
    .status-bar {
        flex-shrink: 0;
        display: flex;
        align-items: center;
        gap: 20px;
        padding: 5px 15px;
        background-color: #252526;
        border-bottom: 1px solid #3e3e3e;
        font-size: 12px;
    }
    
    .status-item {
        display: flex;
        align-items: center;
        gap: 5px;
    }
    
    .status-label {
        color: #858585;
    }
    
    .status-badge {
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 11px;
        font-weight: 600;
    }
    
    .status-success {
        background-color: #1e4620;
        color: #4ec9b0;
    }
    
    .status-error {
        background-color: #5a1d1d;
        color: #f48771;
    }
    
    .status-neutral {
        background-color: #3e3e3e;
        color: #858585;
    }

    .main-content {
        display: flex;
        flex: 1;
        overflow: hidden;
    }

    .left-panel {
        display: flex;
        flex-direction: column;
        width: 50%;
        border-right: 1px solid #3e3e3e;
    }

    .right-panel {
        display: flex;
        flex-direction: column;
        width: 50%;
    }

    .shader-editor {
        flex: 1;
        display: flex;
        flex-direction: column;
        border-bottom: 1px solid #3e3e3e;
    }

    .monaco-editor-container {
        flex: 1;
        width: 100%;
        min-height: 400px;
    }

    .code-editor {
        flex: 1;
        width: 100%;
        background-color: #1e1e1e;
        color: #d4d4d4;
        border: none;
        font-family: 'Consolas', 'Monaco', monospace;
        font-size: 14px;
        padding: 10px;
        resize: none;
    }

    #preview-canvas {
        cursor: crosshair;
        outline: none;
    }

    #preview-canvas:focus {
        outline: 2px solid #007acc;
    }

    .log-panel {
        height: 200px;
        display: flex;
        flex-direction: column;
        background-color: #252526;
    }

    .log-header {
        padding: 5px 10px;
        border-bottom: 1px solid #3e3e3e;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .log-content {
        flex: 1;
        overflow-y: auto;
        padding: 5px 10px;
        font-family: 'Consolas', 'Monaco', monospace;
        font-size: 12px;
    }

    .log-entry {
        margin-bottom: 2px;
    }

    .preview-container {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #000;
        position: relative;
    }

    #preview-canvas {
        max-width: 100%;
        max-height: 100%;
    }
    

    .music-player-container {
        height: 100px;
        border-top: 1px solid #3e3e3e;
    }

    .nav-tabs {
        border-bottom: 1px solid #3e3e3e;
    }

    .nav-tabs .nav-link {
        color: #d4d4d4;
        background-color: #2d2d30;
        border: none;
    }

    .nav-tabs .nav-link.active {
        background-color: #1e1e1e;
        color: #fff;
    }
</style>
