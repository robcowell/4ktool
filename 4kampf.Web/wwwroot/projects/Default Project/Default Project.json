{
  "name": "Default Project",
  "synth": 4,
  "sointuSongFile": "physics_girl_st.yml",
  "enableStandardUniforms": true,
  "enableCamControls": true,
  "enableEnvelopeSync": false,
  "usePostProcess": true,
  "useVertexShader": true,
  "enableLooping": false,
  "useWasmRendering": true,
  "vertexShader": "#version 300 es\n// This is the default vert shader for WebGL.\n\n// It shows how to use 4kampf\u0027s camera system to get an RM ray dir\n// when composing scenes (ofc you use a different means of cam \n// control in the final prod).\n\nprecision mediump float;\n\nuniform vec3 u;\t\t\t// If Standard Uniforms are enabled, this gives {xres, yres, time}\nuniform vec3 cp,cr;\t\t// If the camera system is enabled, these give cam pos and rotation\n\nin vec2 a_position;\t\t// Position attribute\n\nout vec2 uv;\t\t\t// uv coord\nout vec3 rd;\t\t\t// ray direction for RM\n\nfloat scale = 0.41;\nvoid main(){\n\t// Must be set\n\tgl_Position = vec4(a_position, 0.0, 1.0);\n\n\t// Calculate uv\n\tuv = (a_position \u002B 1.0) / 2.0;\n\n\t// Calculate ray direction\n\tvec3 h = cos(cr), j = sin(cr);\n\trd = mat3(\n\t\th.y*h.z, -h.y*j.z, j.y,\n\t\th.x*j.z\u002Bh.z*j.x*j.y, h.x*h.z-j.x*j.y*j.z, -h.y*j.x,\n\t\tj.x*j.z-h.x*h.z*j.y, h.z*j.x\u002Bh.x*j.y*j.z, h.x*h.y\n\t) * vec3(a_position.x*u.x/u.y*scale, a_position.y*scale, u.y/u.x);\n}",
  "fragmentShader": "#version 300 es\n// This is the default frag shader for WebGL.\n\nprecision mediump float;\n\nuniform vec3 u;\t\t\t\t\t// Standard uniforms; time in .z. Also using cam pos cp.\nuniform vec3 cp;\nuniform vec3 cr;\n\nin vec2 uv;\nin vec3 rd;\t\t\t\t\t\t// Ray direction\n\nout vec4 c;\n\nfloat d,M=.001;\t\t\t\t\t\t// Epsilon\n\nvec3 rp(vec3 p,vec3 c){\t\t\t\t// Domain repeat util\n\treturn mod(p,c)-c/2.;\n}\n\nfloat h(vec3 p){\t\t\t\t\t// The distance function\n\tp=rp(p,vec3(15));\n\treturn length(p)-3.;\n}\n\nvec3 nr(vec3 p){\t\t\t\t\t// Estimate normal at p\n\tvec2 e=vec2(M,0);\n\treturn vec3(h(p\u002Be.xyy)-h(p-e.xyy),h(p\u002Be.yxy)-h(p-e.yxy),h(p\u002Be.yyx)-h(p-e.yyx));\n}\n\nfloat ao(vec3 p,vec3 n,float s){\t// Do AO for point p with normal n and strength s\n\tfloat e=1.,a=1.;\n\tfor(float i=1.;i\u003C4.;i\u002B\u002B){\n\t\te*=2.;\n\t\ta-=(i*s-h(p\u002Bn*i*s))/e;\n\t}\n\treturn a;\n}\n\nvoid main(){\t\t\t\t\t\t// Entrypoint\t\n\tvec3 v=gl_FragCoord.xyz/u.xyz-.5,q=cos(cr),ppp=sin(cr),g=v\u002B.5,\t\t\t\t\t\t// Calc ray dir\n\t\tr=normalize(mat3(\n\t\t\tq.y*q.z,0,ppp.y,\n\t\t\tq.z*ppp.x*ppp.y,q.x*q.z,-q.y*ppp.x,\n\t\t\t-q.x*q.z*ppp.y,q.z*ppp.x,q.x*q.y\n\t\t)*vec3(v.x*u.x/u.y*.2,v.y*.2,u.y/u.x)),p=cp;\n\t\n\tfor(int i=0;i\u003C128;i\u002B\u002B){\n\t\td=h(p)-M;\n\t\tif(d\u003CM)break;\n\t\tp\u002B=r*d;\n\t}\n\tif(d\u003CM){\n\t\tvec3 dc=vec3(.6,.3,.7)*h(p-.1)*16.,\n\t\tn=nr(p);\n\t\tdc=mix(dc/2.,dc,ao(p,n,.5));\n\t\tc=vec4(dc, 1.0);\n\t}else\n\t\tc=vec4(vec3(abs(sin(u.z)),.1,.4), 1.0);\n}",
  "postProcessShader": "#version 300 es\n// This is the default postprocessing shader for WebGL\n\nprecision mediump float;\n\nuniform sampler2D fr;\t// The rendered frame\nuniform vec3 u;\t\t\t// Standard uniforms\n\nin vec2 uv;\t\t\t\t// uv\n\nout vec4 fragColor;\n\nvoid main() {\n\t// Alternatively method to calculate uv here if needed:\n\t//vec2 uv=.5\u002B(gl_FragCoord.xy/vec2(u.x,u.y)-.5);\n\t\n\tvec4 c=texture(fr,uv);\n\t\n\t// Film grain\n\tfloat q=uv.x*uv.y*sin(u.z)*7777.;\n\tc*=1.\u002Bclamp(.1\u002Bmod(mod(q,223.)*mod(q,11.),.01)*100.,0.,5.)/5.;\n\t\n\t// Flicker\n\tc*=.97\u002B.03*sin(600.*u.z);\n\t\n\t// Scanlines\n\tc*=.95\u002B.05*sin(9.*u.z\u002Buv.y*980.);\n\t\n\t// Vignette\n    c*=.4\u002B8.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y);\t\t\t\t\t\n\t//c*=sin(uv.x)*sin(1.-uv.x)*sin(uv.y)*sin(1.-uv.y)*16.;\n\t\n\tfragColor=vec4(c.xyz, 1.);\n}",
  "createdAt": "2025-12-23T13:47:25.368138Z",
  "modifiedAt": "2025-12-23T13:47:25.375807Z",
  "gitRemote": null
}